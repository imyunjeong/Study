# 윤성우의 열혈 파이썬(중급)


### 목차
1. [레퍼런스 카운트와 가비지 컬렉션](#1-reference-count--garbage-collection)
2. [수정 가능한 객체와 수정 불가능한 객체](#2-immutable--mutable-object)
3. [깊은 복사와 얕은 복사](#3-deep-copy--soft-copy)
4. [리스트 컴프리헨션](#4-list-comprehension)


# 1. Reference Count & Garbage Collection

* 파이썬 인터프리터(Interpreter): 파이썬 (소스 → 바이트)코드 변환기, 가상머신, 기본적으로 포함되는 각종 라이브러리들의 집합
* 파이썬 가상 머신(Python Virtual Machine, PVM) : 파이썬 프로그램의 실행 주체 (가비지 컬렉션도 진행)
* 가비지 컬렉션(Garbage Collection) : 생성된 객체를 아무도 참조하지 않는 상황에서 일련의 소멸 규칙 및 과정 
* 레퍼런스 카운트(Reference Count) : 객체를 참조하는 변수의 수

다음 상황에서 리스트는 소멸 대상이 된다.
```python
>>> a = [1,2,3]   # a라는 이름으로 리스트를 참조
>>> a = 'sample'  # 변수 a이 참조 대상을 문자열로 변경

# 레퍼런스 카운트하기
r1 = [1,2,3]      # 리스트의 레퍼런스 카운트는 1
r2 = r1           # 리스트의 레퍼런스 카운트는 2
r1 = 'sample'     # 리스트의 레퍼런스 카운트는 1
r2 = 'happly'     # 리스트의 레퍼런스 카운트는 0 (가비지 컬렉션 대상)
```

# 2. Immutable & Mutable Object

* `id()` 메서드를 통해 객체의 주소 값을 확인

* mutable 객체 : 객체에 저장된 값의 수정이 가능한 객체 (e.g. 리스트, 딕셔너리)
   * 리스트에 저장된 값을 수정해도 리스트의 주소가 변경되지 않음
   * 즉, `id()`가 동일한 객체로 유지

* immutable 객체 : 객체에 저장된 값의 수정이 불가능한 객체 (e.g. 튜플, 문자열)
   * 튜플에 저장된 값을 수정하면 새로운 튜플이 생성됨
   * 즉, `id()`가 다른 튜플 객체가 생성

```python
# mutable 객체
>>> r = [1,2,3]
>>> id(r)
51637384
>>> r += [4,5]
>>> id(r)        
51637384         # 리스트에 값이 추가되어도 리스트의 주소가 변경되지 않음

# immutable 객체
>>> t = (1,2,3)
>>> id(t)
58040192
>>> t += (4,5)   # 이때 새로운 튜플이 생성된다
>>> id(t)        # 튜플에 값이 추가되면 튜플 주소가 변경됨
53173968
```

#### Q. mutable vs immutable 의 레퍼런스 카운트가 증가하면.. 각각 메모리 관리는 어떻게 하는 게 효과적인가?


# 3. Deep Copy & Soft Copy

#### 두 객체의 비교 및 복사
* `is` 연산은 두 변수가 참조하는 객체의 주소가 같으면 True, 다르면 False 반환
* `==` 연산은 두 변수가 참조하는 객체의 값이 같으면 True, 다르면 False

* 리스트 안에 선언되는 각 요소 값(객체)들을 리스트 내에서 참조하는 형태

```python
r1 = [1,2,3]
r2 = [1,2,3]
>>> r1 == r2    # 변수 r1과 r2가 참조하는 "객체의 내용(값)이 같은가?"
True
>>> v1 is v2    # 변수 r1과 r2가 참조하는 "객체는 (주소가) 같은가?"
False

# is 연산이 True를 반환하는 경우
>>> r3 = r2
>>> r2 is r3    
True
```

* 얕은 복사(Soft Copy) : 파이썬이 복사를 진행하는 기본 방식
   * immutable 객체는 얕은 복사를 해도 문제가 되지 않음 (문자열, 튜플 객체의 경우 얕은 복사를 진행하는 것이 더 합리적임)
   * mutable 객체는 얕은 복사를 하면 문제가 될 수 있음

* 깊은 복사(Deep Copy)
   * 

```python
# 리스트의 객체 참조
>>> r4 = ['John', ('man', 'USA'), [12, 55]]
>>> r5 = list(r4)  # r4의 내용으로 새로운 리스트 생성
>>> r4 is r5
False
>>> r4[0] is r5[0]
True
>>> r4[1] is r5[1]
True
>>> r4[2] is r5[2]
True
```



# 4. List Comprehension


# 5.
# 6.
# 7.
# 8.
# 9.
# 10.
# 11.
# 12.




#### ETC
```python 
def min_max(d):
    d.sort()   # 리스트를 오름차순으로 정렬 # list.sort() : 리스트 메서드
    print(d[0], d[-1], sep=', ')

```
* print 기능 : `sep=', '` 옵션을 추가할 경우, 한 줄로 출력된다.
